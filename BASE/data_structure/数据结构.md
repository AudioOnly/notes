

### 链表

头结点、尾结点

* 单链表
* 静态链表
* 循环链表
* 双向链表


### 栈

* 普通栈
* 共享栈 将结构分为两块区域

四则运算，中缀表达式转后缀表达式，在求值。


转后缀表达式的过程：数字输出，符号入栈，如果栈定符号的优先级低于即将要入栈的符号，则输出符号。遇到()这种，将他匹配到的符号依次出栈输入。

后缀表达式求值的过程，挨个入栈，与运算符求值，得到的值入栈。

### 队列

* 普通的队列
* 循环队列，为了解决出队列，所有元素都要移动的问题，引入两个指针，一个指向队头，另一个指向队尾的下一个。这种结构队头队尾是移动的。那么，如何解决两个指针同位置，但是是队列满的情况。队尾预留一个位子 不允许插入数据。（队尾指针＋1） % 队列长度 ＝ 队首指针 则队列满。
* 队列的链式存储结构 链队列

### 串

由零个或者多个字符组成的有序队列，又叫字符串。

* 朴素的模式匹配算法 一个一个比
* kmp模式匹配算法 一个一个比，但是跳过前一次比较 已经确定不可能像等的部分，先推导next数组。

>部分匹配表的生成规则，字符串的前缀，后缀，共享部分的长度，就是,到第j个，求j－1串的前后缀共享元素长度

[july kmp算法博客](http://blog.csdn.net/v_july_v/article/details/7041827)

移动的规则，如果部分匹配值是2，当前位置是j，那么就一动j-next[j].


如何求得next数组。

* 先求出前缀和后缀的最长公共元素的长度
* next数组是除去当前的，所以 1步骤整体右移一位，初值-1

个人觉得还是 大话数据结构里那个好理解。


### 树

* 根结点
* 内部结点
* 叶结点或终端结点
* 结点的度：结点拥有的子树称为结点的度
* 结点的关系
	* 父结点 双亲结点
	* 兄弟结点
	* 孩子结点 
* 结点的层次 从根节点开始算
* 深度 树中最深结点的层次


#### 树的存储结构

* 双亲表示法 －－－[ data parent ]，根节点的parent＝－1，为了要找到结点孩子，增加一个域，叫长子域，表示第一个孩子，可以增加一个域，代表这个结点的兄弟，没有为－1，但是这样之后，反而变的复杂。
* 孩子表示法 把每个结点的孩子结点排列起来，以单链表作存储结构孩子[child next]，结点 [data firstchild],为了知道每个的父结点，在结点处加一个parent。
* 孩子兄弟表示法 [data firstchild rightslib]

#### 二叉树

一个根结点和两棵互补相交的、分别称为根结点、左孩子、右孩子

特点：

* 每个结点最多有两棵子树，每个结点的度最多为2
* 左子树和右子树是有顺序的
* 即使只有一颗子树，也要区分是左还是右

二叉树的五种基本形态

* 空二叉树
* 只有一个根结点
* 根结点只有左子树
* 根结点只有右子树
* 都有

特殊的二叉树

* 斜树  左斜树 右斜树
* 满二叉树 既有左子树也有右子树，并且所有叶子都在一层上
* 完全二叉树 编号为i的结点与同様深度的满二叉树中变好味i的结点在二叉树中位置完全相同，则称为完全二叉树

二叉树的性质：

* 第i层，最多有2 i-1次个结点
* 深度味k的二叉树 最多有2的k次方－1个结点
* 叶子结点为n0，度为2的结点为n2，n0=n2+1
* 结点数为n，则层次为log2n +1

#### 二叉树的存储结构

* 顺序结构一般只用于完全二叉树
* 二叉链表 [lchild data rchild]


#### 遍历二叉树

* 前序遍历 先父，后左，后右
* 中序遍历 先左，后父，后右
* 后序遍历 先右，后左，后父
* 层次遍历

关于这个，前中后 是指根节点。


#### 二叉树的建立

利用递归的原理。

#### 线索二叉树

将二叉树空指针的地方用起来。

对二叉树以某种次序遍历使其变为线索二叉树，前驱和后继。

[lchild ltag data rtag rchild]

* ltag 为0 指向孩子，为1指向前驱。

在二叉树线索链表上添加一个头结点，rchild区域指向中序遍历的最后一个结点。


#### 树、森林、二叉树的转换

树转化为二叉树

* 在所有兄弟之间加线
* 每个结点 只保留与第一个孩子的线
* 调整层次


森林转化为二叉树

* 把每个树传华为二叉树
* 第一个二叉树不动，从第二个二叉树开始，依次把后一棵二叉树的根节点座位前一颗二叉树的根节点的有孩子，连起来



二叉树转化为树

* 加线 将左孩子的右孩子结点 当作此结点的孩子
* 去线 删除掉原二叉树所有结点与其右孩子结点
* 层次调整 

二叉树转换为森林

* 从根结点开始，若右孩子存在，把与右孩子结点的连线删除，重复操作
* 将每个二叉树转化为树

树与森林的遍历

* 先根遍历树
* 后跟遍历树

#### 哈夫曼树

从树中一个结点到另一个结点之间的分之构成两个结点的路径，路径上的结点树木成为路径长度。

树的路径长度就是树根到每一个结点的路径长度之和。

* 权 
* 带权路径长度wpl最小的二叉树称为哈夫曼树
* 小左大右

哈夫曼编码
左0右1，从根到结点的编码就是哈夫曼编码。

功能 实现压缩。

那么，如何实现解压呢？根据约定好的树进行解码




### 图

由顶点的有穷非空集合和定点之间的边的集合组成，通常表示G(V,E),其中，g表示一个图，v是图中顶点的集合，e是边。

* 无向边 顶点到顶点之间的边没有方向，则称这条边卫无向边。()表示
* 有向边  也称为弧<a,d> a到d的右向边


_ _ _ 

* 无向完全图，任何两个结点之间都有边
* 有向完全图 任何两个结点之间都有相反的两条弧
* 有很少的边称为稀疏图，反之，稠密图
* 网 （权）边或弧有数字，组成的就叫网
* 子图 
* 出度 入度
* 路径 路径的长度是路径上的边或弧的数目
* 回路 或环  第一个顶点到最后一个顶点相同的路径，序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路 或者简单环。

_ _ _

* 连通图 在无向图中，如果顶点v到v1有路径，这是连通的，如果任意两点都是连通，就是连通图。
* 无向图中的极大连通子图为连通分量。
* 有向图 强连通图 强连通分量
* 一个连通图的生成树是一个极小的连通子图，他包含途中全部的n个顶点，但只有足以构成一棵树的n－1条边。
* 如果又一个有向图恰有一个顶点的入度是0，其他顶点的入度是1，这是一个有向树
* 一个有向图的生成森林 由若干棵有向树组称，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

#### 图的存储结构

* 领接矩阵 二位数组，横竖都是顶点，有边为1，没边为0
* 满足aij ＝ aji的矩阵 叫对称矩阵
* 要知道某个顶点的度，只需要知道第i列或者i行的和。

网的表示，因为网的边有长度，所以矩阵表示的是。

* 自己到自己  0
* 没有 没有边 是无穷
* 其余这是边的长度

连接矩阵对于边比较少的情况，存在比较大的空间浪费

* 邻接表，将每个顶点都当成[data 指针]，指针指向第一个顶点，这里的第一个顶点是指标号较小的一个，
* 这样网也好弄，就是在[data weight 指针]

十字链表 有向图的一种存储方式

* 顶点表结构 [data firstin firstout]
* 边表结点 [tailvex headvex headlink taillink] tailvex 指弧起点在顶点表的下表，headvex 弧终点在顶点表中的下表，headlink 指向终点相同的下一条边，taillink指向起点相同的下一条边，如果是网，加一个weight域


对无向链表进行优化

[ivex ilink jvex jlink] ivex jvex 是连接边的两个顶点在顶点表中的下表，ilink指向依附顶点ivex的下一条边。 这就是邻接多重表结构。

边集数组 由两个一维数组组成，一个存储顶点的信息，另一个存储边的信息，这个边数组每个数据元素由一条边的起点下表、终点下表盒权组成。

#### 图的遍历

从图的某一项顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。

* 深度优先遍历 dfs 从图中某个顶点v出发，访问此顶点，然后从v的尾摆访问的邻接点出发深度优先遍历图，直到图中所有盒vyou路径相遇的顶点都没访问到。对于非连接图，只需要对它的连接份量分别进行深度优先遍历。
* 广度优先遍历 bfs


#### 最小生成树

我们把构成连通网的最小代价生成树称为最小生成树。

* 普里姆算法 prim算法
* 克鲁斯卡尔算法

##### prim算法

每次都是找最小的路径。

##### 克鲁斯卡尔算法 

#### 最短路径

两点之间经过边上权值之和最少的路径，一个顶点时源点，另一个顶点时终点。

* 迪杰斯特拉（dijkstra）算法 每一步都是求出相邻最近的
* 弗洛伊拉（floyd）算法

#### 拓扑排序


在一个有向图中，顶点表示活动，弧表示活动之间的优先关系，我们称为aov图。

拓扑排序就是对一个有向图构造拓扑序列的过程。如果此网的全部顶点都被输出，则说明它时不存在环（回路）的aov网，如果输出的少了，则是有环。

拓扑排序算法：从aov网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，重复，直到输出全部顶点，或不存在入度尾0的顶点。

[in data firstedge]

这里的邻接表 ，是以结点为出度的链接其他的。

#### 关键路径

在一个表示工程的带权有向图中，用顶点表示事件，边表示活动，用边删的权值表示活动的持续时间， ，aoe网。

各个活动持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。

关键路径算法原理。

### 查找

* 顺序查询

顺序查询的油画，设置一个哨兵。从后往前，到了哨兵就查询完毕，省去了数组越界检查的过程。

#### 有序表查找

* 折半查找，也叫二分查找，binary search logn
* 插值查找 差值计算 (key - min)/max-min
* 奜波那契查找 利用黄金分割

#### 线性索引查找

* 稠密索引  将数据集中的每个记录对应一个索引项
* 分块索引  若干块 块内无序，块间有序
* 倒排索引  记录号逼啊存储具有相同次关键字的所有记录的记录号。


#### 二叉排序树 又称二叉查找树

查找操纵 略。

插入操作 查找到合适到的位置插入。


删除操作，删除操作需要考虑 删除枝干结点的情况，将这个结点的的下个结点的右结点放在删除的结点处。

#### 平衡二叉树 avl树

平衡二叉树，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多一。左子树深度－右子树深度的值称为平衡因子bf。


平衡二叉树的实现原理

每当插入一个结点时，先检查是否因插入而破环了树的平衡性，若是，则找出最小不平衡子树，在保持特性的情况下调整最小不平衡树中各结点的链接关系，进行相应的旋转。


左旋：将a点的右子树和a的父亲连起来，把a吊起来（指定左右子树的过程）
右旋：将a的左子树和父亲相连，吊起来

如果没有左右子树，把他当结点吊起来。

实现算法

* 首先实现左旋 右旋操作
* 左平衡旋转处理函数

#### 多路查找树 b树

每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。

* 2-3树
* 2-3-4树
* b树
* b+树

2-3树  每一个结点都具有两个孩子或三个孩子。两结点包含一个元素和两个孩子或没有孩子，三结点包含两个元素和三个孩子，或者没有孩子。

2-3树的插入实现：

*  空树 插入一个2结点
*  插入结点到两结点的叶子上，需要将其升级为三结点
*  往三结点插入新元素，需要将其拆分

2-3-4树

2-3树的扩张，一个4结点包含小中大三个元素和四个孩子（或么有孩子）


b树 平衡的多路查找树，2-3树和2-3-4树都是b树的特例，结点最大的孩子数目称为b树的阶

b＋树 根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。

#### 散列表查找

怎么才算好的散列函数

* 计算简单
* 散列地址分布均匀

- 字节定址法
- 数字分析法
- 平方取中法
- 折叠法
- 除留余数法
- 随机数法

如何解决hash冲突

* 开放地址法 一旦发生冲突，就去寻找下一个空的散列地址
	* 线性探测法
	* 二次探测法 
	* 随机探测法
* 再散列函数 事先准备多个散列函数
* 链地址法 不换地址，换成链表的方式
* 公共溢出区法 建立一个公共溢出区来存放

### 排序

* 冒泡排序 bubble sort，冒泡排序优化，加flag 标记是否交换过一次，加换过
* 简单选择排序 通过n-1次关键字的比较，找出最小的记录，和i交换
* 直接插入排序 插入到以排好序的里面
* 希尔排序 将相距某个增量的记录组成一个子序列，这样才能保证在子血咧哪分别进行直接插入排序后到的的结果是基本有序而不是局部有序
* 堆排序 堆事完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大项堆，小于或等于，称为小项堆。将待排序的序列构成一个大顶堆，与堆数组的末尾元素交换，，重复
	* 从无序序列构造堆
	* 调整剩余元素成为新堆
* 归并排序 两两比较
* 快速排序 通过一趟排序分为两部分，左大右小
	 














