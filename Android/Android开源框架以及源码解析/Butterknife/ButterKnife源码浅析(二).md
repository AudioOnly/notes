本篇来学习记录下compiler的源码。

### 1.ButterKnifeProcessor

这个类用@AutoService(Processor.class)注释了，就省去我们手写配置的过程了。

### 2.一些常量变量

* Type类型 包括view、color、bitmap等等，值为其具体类的完整路径
* LISTENERS，注解类class对象集合
* SUPPORTED_TYPES 支持的类型
* elementUtils 元操作符的辅助类
* typeUtils typeUtils 注解作用域的辅助类
* filer 用于去创建源代码，文件、辅助

### 3.init初始化方法
```
  @Override public synchronized void init(ProcessingEnvironment env) {
    super.init(env);

    elementUtils = env.getElementUtils();
    typeUtils = env.getTypeUtils();
    filer = env.getFiler();
    try {
      trees = Trees.instance(processingEnv);
    } catch (IllegalArgumentException ignored) {
    }
  }
```

* 初始化一些辅助类以及trees(语法树，这个我也不会)

### 4.getSupportedAnnotationTypes

这个方法返回Processor支持的注解类型。
```
  @Override public Set<String> getSupportedAnnotationTypes() {
    Set<String> types = new LinkedHashSet<>();
    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {
      types.add(annotation.getCanonicalName());
    }
    return types;
  }
```

```
  private Set<Class<? extends Annotation>> getSupportedAnnotations() {
    Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();

    annotations.add(BindArray.class);
    annotations.add(BindBitmap.class);
    annotations.add(BindBool.class);
    annotations.add(BindColor.class);
    annotations.add(BindDimen.class);
    annotations.add(BindDrawable.class);
    annotations.add(BindFloat.class);
    annotations.add(BindInt.class);
    annotations.add(BindString.class);
    annotations.add(BindView.class);
    annotations.add(BindViews.class);
    annotations.addAll(LISTENERS);

    return annotations;
  }
```

可以看到，支持的注解类型为annotations的注解,

### 5.process方法

这个方法是生成文件的关键方法。

```
  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
    Map<TypeElement, BindingClass> targetClassMap = findAndParseTargets(env);

    for (Map.Entry<TypeElement, BindingClass> entry : targetClassMap.entrySet()) {
      TypeElement typeElement = entry.getKey();
      BindingClass bindingClass = entry.getValue();

      JavaFile javaFile = bindingClass.brewJava();
      try {
        javaFile.writeTo(filer);
      } catch (IOException e) {
        error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
      }
    }

    return true;
  }
```
其中有三个关键的地方

* findAndParseTargets 
* bindingClass.brewJava()
* javaFile.writeTo(filer)

接下来就分别来说明这三个的作用。

### 6.findAndParseTargets

该方法主要分为三个步骤

* 解析@BindArray 这种类型的数据绑定或者视图绑定
* findAndParseListener，去做事件绑定
* 尝试去每一个绑定的parent绑定

#### 6.1 以@BindView为例。
```
    // Process each @BindView element.
    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
      // we don't SuperficialValidation.validateElement(element)
      // so that an unresolved View type can be generated by later processing rounds
      try {
        parseBindView(element, targetClassMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindView.class, e);
      }
    }
```
找到有@BindView的元素之后，调用paraseBIndView方法去解析，

parseBindView 方法。
这个方法较长，简单的分析下关键代码。

```
TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
```
获取元素的封装类型

```
    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
        || isBindingInWrongPackage(BindView.class, element);
```
验证是否有错误。

然后通过代码得到类型。

```
  int id = element.getAnnotation(BindView.class).value();
```
得到view的id，
```
BindingClass bindingClass = targetClassMap.get(enclosingElement);
```
得到BindingClass对象，如果对象不为null，在进一步得到ViewBindings，如果不为null并且fieldBinding也不能null的话，就说名已经绑定过了。如果为null的话。getOrCreateTargetClass，这方法的用户是创建一个BindingClass对象，并将其放入到targetClassMap中。回到上面的方法。
```

    String name = element.getSimpleName().toString();
    TypeName type = TypeName.get(elementType);
    boolean required = isFieldRequired(element);

    FieldViewBinding binding = new FieldViewBinding(name, type, required);
    bindingClass.addField(getId(id), binding);

    // Add the type-erased version to the valid binding targets set.
    erasedTargetNames.add(enclosingElement);
```
将这个元素加入到set中。

#### 6.2 findAndParseListener

这个方法中调用parseListenerAnnotation方法。

* 获取属性值
* 生成MethodViewBinding
* 加入到set中。

### 7.BindingClass#brewJava方法

这里就是用javapoet生成java代码的

```
  JavaFile brewJava() {
    return JavaFile.builder(bindingClassName.packageName(), createBindingClass())
        .addFileComment("Generated code from Butter Knife. Do not modify!")
        .build();
  }
```
