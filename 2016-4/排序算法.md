##### Java 排序算法
排序算法大的分类可以分为两种：内排序和外排序

* 内排序 在排序过程中，全部记录存放在内存，则称为内排序/
* 外排序 在排序过程中，如果排序过程中需要使用外存，则陈伟外排序。

以下均为内排序。分类如下：

* 插入排序 
 * 直接插入排序
 * 二分法插入排序
 * 希尔排序
* 选择排序
 * 简单选择排序
 * 堆排序
* 交换排序
 * 冒泡排序
 * 快读排序
* 归并排序
* 基数排序

###### 1. 直接插入排序
* 基本思想-每步将一个待排序的记录，暗器顺序码大小插入到前面已经排序的序列的合适位置。(从后向前找到合适位置)
* 实例代码
```
public void insertSort(){
		int temp = 0;
		for (int i = 1; i < a.length; i++) {
			int j = i -1;
			for(;j>=0&& temp < a[j];j--){
				//大于temp的值整体向后移一位
				a[j+1] = a[j];
			}
			a[j+1] = temp;
		}
	}
```

* 稳定的排序，最好的事件复杂读是o(n),最换的情况是o(n*n)；

###### 2. 二分法插入排序(按二分法找到合适的位置插入)

* 基本思想 根据二分查找找打合适的位置插入
* 实例代码
```
public void erfenSort(){
		for (int i = 0; i < a.length; i++) {
			int temp = a[i];
			int left = 0;
			int right = i -1;
			int mid = 0;
			while(left<=right){
				mid = (left+right)/2;
				if(temp<a[mid]){
					right = mid-1;
				}else{
					left = mid +1;
				}
			}
			for (int j = i-1; j < a.length; j++) {
				a[j+1] = a[j];
			}
			if (left!=1) {
				a[left] = temp;
			}
		}
	}
```

* 稳定的排序 最坏的情况为o(n*n/2),最好为o(n),平均的情况为o(n*n)

###### 3. 希尔排序

* 基本思想 先取一个下小于n的证书d1作为第一个增量，吧文件的全部记录分为d1个组。所有距离为d1的背书的记录房子同一个组中，先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取增量dt=1（dt<dt-1<...<d1，既所有的记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。

* 实例代码
```
int d = a.length;
         while(true){
             d = d / 2;
             for(int x=0;x<d;x++){
                 for(int i=x+d;i<a.length;i=i+d){
                     int temp = a[i];
                     int j;
                     for(j=i-d;j>=0&&a[j]>temp;j=j-d){
                         a[j+d] = a[j];
                    }
                     a[j+d] = temp;
                 }
            }
             if(d == 1){
                 break;
             }
         }
```

* 希尔排序是不稳定的，希尔排序的性能优于直接插入排序。

##### 4.简单选择排序
* 基本思想 在要排序的一组数中，选出最小的一个数与第一个数交换，然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
* 代码实例

	```
for (int i = 0; i < a.length; i++) {
             int min = a[i];
             int n=i; //最小数的索引
             for(int j=i+1;j<a.length;j++){
                 if(a[j]<min){  //找出最小的数
                     min = a[j];
                     n = j;
                 }
             }
            a[n] = a[i];
             a[i] = min;
         }
```
* 不稳定排序，o(n*n)

##### 5.堆排序
* 基本思想 堆排序是一种属树形选择排序，是对直接选择排序的有效改进。
* 堆的定义：具有n个元素的队列，当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1） (i=1,2,...,n/2)时称之为堆，堆顶元素毕伟最大项。完全二叉树可以很只管表示堆的结构，
* 思路 初始时把要排序的序列看做是一颗顺序存储的二叉树，调整他们的存储序，使之称为一个堆。，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。

* 代码实例
```
```

##### 6.冒泡排序
* 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数一次进行比较和调整，让较大的数往下沉，较小的往上冒。
* 代码实例

	``` 
public void b_sort(){
		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a.length-i-1; j++) {
				if (a[j]>a[i]) {
					int temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
				}
			}
		}
	}
```

* 一种稳定的排序 

###### 7.快速排序
* 选择一个基准元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。
* 实例代码
```
public void quickSort(int[] a ,int low, int high){
		if (low < high) {
			int middle = getMiddle(a,low,high);
			quickSort(a, 0, middle-1);
			quickSort(a, middle+1, high);
		}
	}
	
	public int getMiddle(int[] a ,int low , int high){
		int temp = a[low];
		while (low<high) {
			while (low<high && a[high]>=temp) {
				high--;
			}
			a[low] = a[high];
			while(low<high && a[low]<=temp){
                low++;
            }
            a[high] = a[low];
		}
		a[low] = temp;
		return low;
	}
```

* 快速排序是不稳定排序，o(nlogn)，当n较大时使用快排比较好，当序列基本有序时用快排反而不好。

##### 8.归并排序
* 基本思想 将2个或2个以上有序表合并成一个新的有序表，即把待排序序列分成若干个子序列，每个子序列都是有序的，然后再把有序子序列合并为整体有序序列。
* 实例代码
```
```

http://www.cnblogs.com/liuling/p/2013-7-24-01.html


