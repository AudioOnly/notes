##### Java 排序算法
排序算法大的分类可以分为两种：内排序和外排序

* 内排序 在排序过程中，全部记录存放在内存，则称为内排序/
* 外排序 在排序过程中，如果排序过程中需要使用外存，则陈伟外排序。

以下均为内排序。分类如下：

* 插入排序 
 * 直接插入排序
 * 二分法插入排序
 * 希尔排序
* 选择排序
 * 简单选择排序
 * 堆排序
* 交换排序
 * 冒泡排序
 * 快读排序
* 归并排序
* 基数排序

###### 1. 直接插入排序
* 基本思想-每步将一个待排序的记录，暗器顺序码大小插入到前面已经排序的序列的合适位置。(从后向前找到合适位置)
* 实例代码
```
public void insertSort(){
		int temp = 0;
		for (int i = 1; i < a.length; i++) {
			int j = i -1;
			for(;j>=0&& temp < a[j];j--){
				//大于temp的值整体向后移一位
				a[j+1] = a[j];
			}
			a[j+1] = temp;
		}
	}
```

* 稳定的排序，最好的事件复杂读是o(n),最换的情况是o(n*n)；

###### 2. 二分法插入排序(按二分法找到合适的位置插入)

* 基本思想 根据二分查找找打合适的位置插入
* 实例代码
```
public void erfenSort(){
		for (int i = 0; i < a.length; i++) {
			int temp = a[i];
			int left = 0;
			int right = i -1;
			int mid = 0;
			while(left<=right){
				mid = (left+right)/2;
				if(temp<a[mid]){
					right = mid-1;
				}else{
					left = mid +1;
				}
			}
			for (int j = i-1; j < a.length; j++) {
				a[j+1] = a[j];
			}
			if (left!=1) {
				a[left] = temp;
			}
		}
	}
```

* 稳定的排序 最坏的情况为o(n*n/2),最好为o(n),平均的情况为o(n*n)

###### 3. 希尔排序

* 基本思想 先取一个下小于n的证书d1作为第一个增量，吧文件的全部记录分为d1个组。所有距离为d1的背书的记录房子同一个组中，先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取增量dt=1（dt<dt-1<...<d1，既所有的记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。

* 实例代码
```
int d = a.length;
         while(true){
             d = d / 2;
             for(int x=0;x<d;x++){
                 for(int i=x+d;i<a.length;i=i+d){
                     int temp = a[i];
                     int j;
                     for(j=i-d;j>=0&&a[j]>temp;j=j-d){
                         a[j+d] = a[j];
                    }
                     a[j+d] = temp;
                 }
            }
             if(d == 1){
                 break;
             }
         }
```

* 希尔排序是不稳定的，希尔排序的性能优于直接插入排序。

##### 4.简单选择排序
* 基本思想 在要排序的一组数中，选出最小的一个数与第一个数交换，然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
* 代码实例

	```
for (int i = 0; i < a.length; i++) {
             int min = a[i];
             int n=i; //最小数的索引
             for(int j=i+1;j<a.length;j++){
                 if(a[j]<min){  //找出最小的数
                     min = a[j];
                     n = j;
                 }
             }
            a[n] = a[i];
             a[i] = min;
         }
```
* 不稳定排序，o(n*n)

##### 5.堆排序
* 基本思想 堆排序是一种属树形选择排序，是对直接选择排序的有效改进。

http://www.cnblogs.com/liuling/p/2013-7-24-01.html


